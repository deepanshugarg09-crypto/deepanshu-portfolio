<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Touchless Troubleshooting | Deepanshu Garg</title>

<style>
body{
  margin:0;
  font-family:Inter,system-ui;
  background:#0b0f19;
  color:#e5e7eb;
}

.container{
  max-width:900px;
  margin:auto;
  padding:40px 20px;
}

h1{margin-bottom:10px;}
h2{color:#60a5fa;margin-top:30px;}

.back{
  color:#60a5fa;
  text-decoration:none;
  display:inline-block;
  margin-bottom:20px;
}

img{
  max-width:100%;
  border-radius:10px;
  margin-top:15px;
  border:1px solid #1f2937;
}

.card{
  background:#111827;
  padding:20px;
  border-radius:12px;
  border:1px solid #1f2937;
}
</style>
</head>

<body>
<div class="container">

<a class="back" href="../index.html">← Back to Portfolio</a>

<h1>Touchless Troubleshooting</h1>

<div class="card">
<h2>What this solution does</h2>
<p>
Client logs are our first need to debug an issue and we really can not reach out to customer every time for logs.
So, we decided to build a system that can fetch the logs from any of the 50 Million devices and upload it our server in no time.
Vision is to proactively identify problematic devices from Grafana dashboard alerts, trigger remote log fetch, 
including packet captures, generate real-time traffic, create a log bundle, and
upload it for Zscaler support to review without customer involvement.
</p>

<h2>Architecture Diagram</h2>
<img src="touchlesstroubleshooting.png" alt="Telemetry Architecture">

<h2>Architectural Description</h2>
<p>
Singleton + Worker Thread — RequestManager is a singleton with a dedicated background thread consuming from a thread-safe queue, decoupling request submission from processing.
Strategy Pattern (Auth) — StatusReporter has two concrete strategies (ModernAuthReporter, LegacyAuthReporter) selected at runtime based on a feature flag.
Pipeline Pattern — PipelineRegistry owns an ordered list of IPipelineStage implementations. Stages are executed sequentially; each stage can halt the pipeline via canProceedToNext.
Dependency Inversion — The core library depends on callbacks (std::function) injected by PlatformAdapter, not on concrete platform types. This enables cross-platform reuse.
TTL Deduplication Cache — Prevents re-processing of the same job within its validity window.
Completion Wait (Packet Capture) — After the NetworkCapture stage, the registry spawns two parallel threads to race between a "stop" event and a "completion" event, with a configurable timeout.
</p>
</div>

</div>
</body>
</html>
