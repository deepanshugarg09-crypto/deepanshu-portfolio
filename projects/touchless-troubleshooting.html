<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Touchless Troubleshooting | Deepanshu Garg</title>

<style>
body{
  margin:0;
  font-family:Inter,system-ui;
  background:#0b0f19;
  color:#e5e7eb;
}

.container{
  max-width:900px;
  margin:auto;
  padding:40px 20px;
}

h1{margin-bottom:10px;}
h2{color:#60a5fa;margin-top:30px;}

.back{
  color:#60a5fa;
  text-decoration:none;
  display:inline-block;
  margin-bottom:20px;
}

img{
  max-width:100%;
  border-radius:10px;
  margin-top:15px;
  border:1px solid #1f2937;
}

.card{
  background:#111827;
  padding:20px;
  border-radius:12px;
  border:1px solid #1f2937;
}
</style>
</head>

<body>
<div class="container">

<a class="back" href="../index.html">← Back to Portfolio</a>

<h1>Touchless Troubleshooting</h1>

<div class="card">
<h2>What this solution does</h2>
<p>
Client logs are our first need to debug an issue and we really can not reach out to customer every time for logs.
So, we decided to build a system that can fetch the logs from any of the 50 Million devices and upload it our server in no time.
Vision is to proactively identify problematic devices from Grafana dashboard alerts, trigger remote log fetch, 
including packet captures, generate real-time traffic, create a log bundle, and
upload it for Zscaler support to review without customer involvement.
</p>

<h2>Architecture Diagram</h2>
<img src="touchlesstroubleshooting.png" alt="Telemetry Architecture">

<h2>Architectural Description</h2>
<ul style="line-height:1.7; padding-left:18px;">
  <li><b>Singleton + Worker Thread</b> — <i>RequestManager</i> is a singleton with a dedicated background thread consuming from a thread-safe queue, decoupling request submission from processing.</li>

  <li><b>Strategy Pattern (Auth)</b> — <i>StatusReporter</i> uses two concrete strategies (<i>ModernAuthReporter</i>, <i>LegacyAuthReporter</i>) selected at runtime via feature flag.</li>

  <li><b>Pipeline Pattern</b> — <i>PipelineRegistry</i> maintains an ordered list of <i>IPipelineStage</i> implementations executed sequentially; stages can short-circuit execution using <i>canProceedToNext</i>.</li>

  <li><b>Dependency Inversion</b> — Core library depends on injected callbacks (<i>std::function</i>) from <i>PlatformAdapter</i> instead of platform-specific types, enabling cross-platform reuse.</li>

  <li><b>TTL Deduplication Cache</b> — Prevents re-processing of identical jobs within their validity window to reduce redundant work.</li>

  <li><b>Completion Wait (Packet Capture)</b> — After the <i>NetworkCapture</i> stage, two parallel threads race between a <i>stop</i> event and a <i>completion</i> event with configurable timeout handling.</li>
</ul>
</div>

</div>
</body>
</html>
